# Attack RSA Part 1

### Original Questions

This week's writeups will discuss all of the attacks mentioned in the lecture notes in order.

#### Private Key Divulged

Suppose Alice has public key `n,e` and ciphertext message `c`:

```
n=25406882428092607653555784140586843904046741824165208478109060605218053525365547445487807404868004853799081063505626955344125235123224892205748787697575177789089964646700253662485906286437998766413936535990986621512410152820735407797563961555943946833838428697833182443504859843565739212621889952929069985693673606772399732027921867611838612371655379825252124429048433906427057312185830848145065228987213865120929209540983463014771220399682541747973827535612108645839369368375520069443157570613227226293021174455545093510035134580422088376912874780648059646187199937278753483311972110891662843175210602104554255996427
e=65537
c = 18011946846098218830226255073651769837380619814213675381428694612814016508727164736104403895945934158858682465488254218529405688842392108617012717334221716413061128014026108793275355622282784662327256070577986899780540782139040183475879347227481944995509641227321283259764364958925122102342816615708340519772822034693556623640214402061263721761527082181461665218923285246787898713184173354345582388518238759974386626651682098906931352660813999948885725331122561627607729563516054786479326152515750253306735398361293538813175650110157732402741397269801754601576805002546606626807378588029835304467854356656660209151439
```

This is a 2048 bit key, and would generally be considered secure. Let's say one of her private parameters got leaked, so we know `p = 158589721278572288725971451484427256228889404443538880838518715056653170044804823661568216667605976179141053221848045577277887845648325145619147000942646611775316438773868258468217010991400442849848691736264954043623397693084257361211332893147365133339505292868781414513762109305755628577432728591047981120207`. How do we recover the message?

First, we need to recover the other factor of `n = p*q`. This means `n/p = q`. `print n/p` reveals `q = 160205101713142592663673342398495768869999214765929075945116283186026166513190477958949440699221985556050501843514235311029653740024472809106426834841696071524378509574226245755931007231508104055970218506226260977066751173600170804981185888528082452185252142280118936327157087300602287991797984134580763283461`.

Next, we can use our knowledge of `p` and `q` to recover the decryption exponent `d`. Recall from last week that `e*d = 1 mod (p-1)(q-1)`. Isolating the unknown, we can rewrite this equivalency as `d = e^(-1) mod (p-1)(q-1)`.

###### Gentle Sage Introduction

Sage's syntax is the [almost] the same as python. Once sagemath is installed on your machine, open a sage shell with the terminal command `sage`. You can start the program by inputting the rsa parameters as before.

```
n=25406882428092607653555784140586843904046741824165208478109060605218053525365547445487807404868004853799081063505626955344125235123224892205748787697575177789089964646700253662485906286437998766413936535990986621512410152820735407797563961555943946833838428697833182443504859843565739212621889952929069985693673606772399732027921867611838612371655379825252124429048433906427057312185830848145065228987213865120929209540983463014771220399682541747973827535612108645839369368375520069443157570613227226293021174455545093510035134580422088376912874780648059646187199937278753483311972110891662843175210602104554255996427
e=65537
c = 18011946846098218830226255073651769837380619814213675381428694612814016508727164736104403895945934158858682465488254218529405688842392108617012717334221716413061128014026108793275355622282784662327256070577986899780540782139040183475879347227481944995509641227321283259764364958925122102342816615708340519772822034693556623640214402061263721761527082181461665218923285246787898713184173354345582388518238759974386626651682098906931352660813999948885725331122561627607729563516054786479326152515750253306735398361293538813175650110157732402741397269801754601576805002546606626807378588029835304467854356656660209151439
p = 158589721278572288725971451484427256228889404443538880838518715056653170044804823661568216667605976179141053221848045577277887845648325145619147000942646611775316438773868258468217010991400442849848691736264954043623397693084257361211332893147365133339505292868781414513762109305755628577432728591047981120207
q = 160205101713142592663673342398495768869999214765929075945116283186026166513190477958949440699221985556050501843514235311029653740024472809106426834841696071524378509574226245755931007231508104055970218506226260977066751173600170804981185888528082452185252142280118936327157087300602287991797984134580763283461
```

Now, since we need to work in mod (p-1)\*(q-1), we can save this in a variable as we would in python.

```
totient = (p-1)*(q-1)
```

Here is where sage shows its utility. Sage allows us to explicitly work in `mod totient` by simply declaring a variable representing what number "ring" we want to work with.

```
R = Integers(totient) #any variables we declare in R will now be mod totient
modvar = R(e) #totient
```

The second line means instead of working with the integer `65537`, we are working with `65537 mod totient`. Compare the results of:

```
print e*totient
print modvar*totient
```

Since the first line are both integers, this will result in normal integer arithmetic. The second line will print `0` because multiplying by the modulus is equivalent to multiplying by 0 in modular arithmetic. Now here is the relevant part - sage implements taking inverses. For normal integers, this just means finding `1/yourvar`. In modular arithmetic, this will be another modular integer.

```
print e^-1 #not what we want, this is just some fraction
print R(e)^-1 #what we want, prints the inverse of e mod totient
```

Now that we have found the decryption exponent, we simply decrypt the ciphertext to find the original message.

```
d = R(e)^-1
print d
```

now switching back over to a python shell...

```
from Crypto.Util.numbers import long_to_bytes
m = pow(c,d,n)
print long_to_bytes(m)
```

This prints out the flag!

#### Small Public Modulus

If the public modulus is small enough, it can be factored. Let's assume the following public key and ciphertext are known:

```
N = 173427049771902118141253231308407841883
e = 65537
c = 28806434663562249073851228008686007775
```

We can use python to figure out how many bits the modulus is.

```
import math
print math.log(N, 2) #or
print len(bin(N))-2 #-2 is to account for the leading '0b'
```

Our result is 128 bits. This is not a secure length for an RSA modulus. Sagemath has a built-in function that can help us.

```
print factor(173427049771902118141253231308407841883)
```

This returns `p =13066773463056423443` and `q = 13272369821228701081`. Now that we know `p` and `q`, we can solve as in the previous question.

```
tot = (p-1)*(q-1)
R = Integers(tot)
e = R(65537)
d = e^(-1)
print pow(c,d,N)
```

Now that we have a numeric result, we can use pycrypto to convert it back to a plaintext.

```
from Crypto.Util.numbers import long_to_bytes
m = pow(c,d,n)
print long_to_bytes(m)
```

And we have the flag.

#### Other bad public moduli

Sometimes large numbers are easy to factor too. Consider the following public key and ciphertext:

```
N = 55361684267444749690566057670772755459030104740612012801874693754770668178456137071294070140303775283072547827725214059372529764661566971136719387709460315091508388244902662699700782731942327365191482722530805276999897722717401064024162241228376033289769245635612231268185763210043415291409656410067969574643
e = 65537
c = 25922152270047827930178796623060512547291141077894987053556816665920675821016982008750069611467930977502976707335961757161804517432678028110491758775872004757348071422348906529567910433477179006508683240366966415687398122876411018538230492700172773735061331199405467759834842463081232084376470983315440887101
```

First, let's check how large N is:

```
print math.log(N,2)
```

This is 1023 bits, which could be secure. Just for the heck of it, let's check out if sage with factor the number for us:

```
factor(n) #prints 3^645
```

Score! Since we factored n, we can compute the decryption key. Because n isn't the product of two primes, we have to use a more general technique to compute the decryption key. Instead of working with modulus `(p-1)*(q-1)`, we work mod `euler_phi(n)`.

Euler's phi function (otherwise known as Euler's totient function) is simply the count of all numbers less than n, relatively prime to n. If you want more info about it, check out the wikipedia article for it. It suffices to use sage's `euler_phi` built-in function to compute this. Everything other computation is the same as before.

```
tot = euler_phi(n)
R = Integers(tot)
e = R(65537)
d = e^(-1)
print pow(c,d,N)
```

Convert this integer to a string and you've got the flag.

#### Small plaintext, small public exponent

For this question, we have N,e,c:

```
N = 80857721649509453737265836488941821859154004391301390158476759340640161492125802229576014433073557813999131954177282168663927186816779421944115602150301633870992933793035698721699733175004349146203379873083879809029018804160794675162297451721485395313827946737124969288573332086827182024334018460573553806229
e = 3
c = 31850476042864913139808606958117651753336705005028863287619961350410739247936210505829L
```

We can compute the number of bits in the modulus and/or attempt to factor it and see that it is secure.

The next thing to notice is that c is much shorter than N. We observe that in the other examples, c is pretty close to N in length. This is extremely unlikely to happen by random chance, so we an assume it is not random. To see the implications of this, consider `2^e mod N = 8`. Because 2 is small enough, the modulus operation doesn't "activate", which means the exponentiation is identical to regular integer exponentiation. In fact, the first number that will be changed by the exponentiation is the first number in which `2^e > N`. We can compute this by taking the `e`th root of `N`. This number is about 341 bits.

With the intuition out of the way, let's take the third root in sage.

```
c.nth_root(3)
```

A big hint that we are correct is how this actually works and returns an integer. If an integer isn't a 3rd power the function will error out. Convert this integer to a string and we have our flag.

#### Weird Public Exponent

For this question we are given:

```
N = 99420401671931501769564952987333797018282019568891609938316270599306153860861558615825340333276585902561126116604580852645636640723355707926804408403423062054646400360477736602730971958827462495843408004467256296464559932704355063480312534184264902481910925989844358476925571489530504360219017016867517464457
e = 948270368071300058286291928860164269830807631005044246044188564875806845116996535606571205971491233614554274566950328957987804523278400824457456415358479785054253596608942261149965050664021563618558848876304492764374719778704974716144963075632016395291415705026193871148209042947349995728932716663605045579
c = 72591418053154512266701168819180990192997953436643812740305952892459452710359373401116350007011742315695082331939592929479690983197334813843743495254646321842433411227096785949785887704047607593532213501914951370077692402137267099457413819780545351388901238868957938663487111220661422068765747739000480172640
```

Let's examine this problem for past weaknesses. The `N` is large and has strong prime factors, so we can't exploit it that way. Also, we can't take the `e`th root of `N`. So we have to try a new attack.

Wiener's Attack on RSA is more mathematically complicated than anything we have done so far, so we won't discuss the fine details too much. It is enough to know that the attack works when the decryption key `d` is small relative to `N`. Since we don't have access to the private key, it is impossible to know if this condition holds beforehand, but having `e` be irregular values (i.e. not 3 or 65537) is an indicator that this attack will work.

Since we don't know how this attack works internally, we must use a public tool to carry out the attack for us. [pablocelayes at github.com](https://github.com/pablocelayes/rsa-wiener-attack) has a tool that has worked for me in the past. Let's try it here:

```
from RSAwienerHacker import hack_RSA #need to be in the same directory as the RSAwienerHacker.py file
print hack_RSA(e,n)
```

The program spits out d quickly, and we can use that to decrypt the message.

#### GCD Broadcast Attack

Consider the following N1,e,c1,N2,c2:

```
e = 65537
N1 = 159427151856059730960292478422112027816245504340014201285514790107942093355476238682441733519390092302531165664591983261663062532008291908275572110590233851158215738816092580731161393693671064242524476353723729007363061006757840389535190066699345525093624461675146266305634448323684080980332065269790491509151
c1 = 66163793386100336532380522686721136141736119628931771376259844114048600000414029505400373571282108563292902757041794945327911112865290999775380448226961955044980481926456559716923864725617990864851784801595225770253887522654663628517377993882287030129354634771735238870372096282179038068190397649838470321327
N2 = 135704046219137297760422212772114295113269297451337761378367961139239468584451117897108717049381157398513038410824697483246800515948410476585015143476675493682386054775535741558112676922873958636153250018323200032773393975242368276107130258224332504270808412091535282541212841889309482360489913055937919700421
c2 = 78319235034702123131716158798545880836302088523391541874160308556254062361990351182353918698838315742664193187596694102462057972075420610678072482399790038854933363489910933447067432756162095577296899561052794898216494500519995742658696035111575986093407388645803140705869183704508448911842942028681120717743
```

We check to see if the previous attacks are valid. They aren't, so we move on to a new attack: The GCD Broadcast Attack. This attack can occur if a cryptosystem designer doesn't use new primes each time they create a public modulus. It is easy to detect with sage when prime reuse occurs:

```
if not gcd(N1, N2) == 1:
    GCDBROADCAST = True
    g = gcd(N1, N2)
    print g
```

Taking a gcd is inexpensive, so this attack does not take long to compute and yields the full private key for an attacker.

If the two moduli aren't coprime, then that means for `N1 = p*q` and `N2 = r*s` (without loss of generality) `gcd(N1,N2) = p = s`, so `N1 = p*q` and `N2 = p*r`. Since `p` is known, compute the other factors with `q = N1/p` and `r = N2/p`. In sage:

```
q = N1/g
r = N2/g
```

Since we now know the factorization of both public moduli, we can compute the private exponent and decrypt.

#### Chinese Remainder Theorem Broadcast Attack

Suppose you know the same message `m` is sent to `e` people, all encrypted with different public keys. This may look like:

```
e = 3
N0 = 98253679475556894135692429123294883088174182582654223992859556016769260307365745770355226264990436531143522169156099494178703890979270068866713764400929916063739538035320690969366924936515473228599652727904606028121986955986688619815633555012478781985638814976709822595183889523154649436816933078387896297271
c0 = 74802199268250240660609004717260131231738956932338730262775568801293359436221429211377023440654196793236530772557682977456736688385794953629811963858952305182314422158470791841424450783881505125
N1 = 75245583407205326452903022887068704693972719133513018278589269298013271206454790897479924821975976842248806333503318306377427952939710203735057944053206654273384250577971196743778460978631831646966699774493406653388454000878067614866407983876707467835114926205790629824242550562582357476346884740414971908309
c1 = 74802199268250240660609004717260131231738956932338730262775568801293359436221429211377023440654196793236530772557682977456736688385794953629811963858952305182314422158470791841424450783881505125
N2 = 104274180467733154468294858114514858758574012673136097289456808806256897166837514753559743784737948165562635496585344642369796738794716387497421829539818374719513853988998072691082555065352126240260086104443881638106697010105763256874544846353292440282001882957792963312477812843837139567142397370441552341189
c2 = 74802199268250240660609004717260131231738956932338730262775568801293359436221429211377023440654196793236530772557682977456736688385794953629811963858952305182314422158470791841424450783881505125
```

Like the previous two attacks, there is no way to verify the condition (that the same message is being encrypted) holds before attempting it, so we will give it a try here anyways.

But first, we will talk about the Chinese Remainder Theorem. This is an algorithm designed to recover some large number when given several remainders of smaller numbers.

For example, if:

```
x = 1 mod 3
x = 1 mod 5
x = 1 mod 7
```

It is easy to deduce x = 1. But if

```
x = 1 mod 3
x = 2 mod 5
x = 3 mod 7
```

The answer is not as trivial to deduce. For the first condition, we know numbers `1,4,7,10,13,16,19,22...` satisfy it. From this list, applying the second condition, only `7 and 22` are congruent to 2 mod 5. neither of these are congruent to 3 mod 7, so this is where the CRT comes in handy. It is a nifty algorithm that gives us `x mod 3*5*7`, or more generally, gives us `x mod product(N1, N2, ... Nl)`, only if all `Ni` are coprime (luckily this condition failing means the GCD broadcast attack will succeed). If interested, I encourage the reader to look it up, but once again sage saves the day here:

```
x = crt(c0,c1,c2,N0,N1,N2)
print x
```

So how does this help us? Recall that in RSA the message `m` must always be less than the modules `N`, or else the message will get altered by the modulation. So if `m < N1,N2,N3`, this means `m*m*m < N1*N2*N3`. This implies `m^3` will not be altered by a modulus `N1*N2*N3`. Since `x = m^3`, and `x` isn't altered by the modulation, the (integral) cube root of `x` will yield `m`. Here is the sage code to show this step:

```
m = x.nth_root(3)
print m
```

This attack doesn't give a full decryption key, but does reveal the message.
